// index.ts
// Renamed main.ts content to index.ts to match package.json main entry point

import { FractalGeometryExtended } from '../core/fractalGeometryExtended';
import { GenesisTriangle } from '../core/genesisTriangle';
import { SierpinskiMiningProtocol } from '../core/sierpinskiMiningProtocol';
import { TripleBurnProtocol } from '../economics/tripleBurnProtocol';
import { AncestralDividendSystem } from '../economics/ancestralDividendSystem';
import { GeometricConsensus } from '../geometricConsensus';
import { SelfOrganizingEconomy } from '../economics/selfOrganizingEconomy';
import { FractalSmartContract } from '../smartContracts/fractalSmartContracts';
import { OracleTriangleSystem } from '../oracle/oracleTriangleSystem';
import { NetworkGovernance } from '../governance/networkGovernance';
import { QuantumTriangleStates } from '../matrix/quantumTriangleStates';
import { LivingMatrix } from '../matrix/livingMatrix';
import { SierpinskiVirtualMachine } from '../core/sierpinskiVirtualMachine';

console.log("Sierpinski Matrix Ledger Protocol (SMLP) - Initializing...");

async function main() {
  console.log("Starting SMLP protocol implementation...");

  // Log fractal geometry principles
  const principles = FractalGeometryExtended.describeFractalGeometryPrinciples();
  console.log("Fractal Geometry Principles:\n", principles);

  // Initialize and demonstrate Genesis Triangle
  const genesisTriangle = new GenesisTriangle();
  genesisTriangle.initializeQuantumState();

  console.log("Genesis Triangle DNA Code:", genesisTriangle.getDnaCode());
  console.log("Total SERP Token Supply:", genesisTriangle.getTotalSupply());
  console.log("Initial Quantum State:", genesisTriangle.getQuantumState());

  // Simulate collapsing quantum state to a definite state
  const collapsedState = { stateId: 1, description: "Initial ledger state" };
  genesisTriangle.collapseQuantumState(collapsedState);

  console.log("Collapsed Quantum State:", genesisTriangle.getQuantumState());

  // Initialize and demonstrate Quantum Triangle States
  const quantumStates = new QuantumTriangleStates();
  const fractalLevel = 2;
  quantumStates.initializeStates(fractalLevel);
  const segments = quantumStates.getAllStates();
  if (segments.length === 0) {
    throw new Error("No quantum triangle states initialized");
  }
  const segmentId = segments[0].segmentId; // Use first segmentId from initialized states
  quantumStates.collapseState(segmentId, { stateId: 1, description: "Collapsed state example" });
  console.log(`Quantum state for segment ${segmentId}:`, quantumStates.getState(segmentId));

  // Initialize and demonstrate Sierpinski Mining Protocol
  const smp = new SierpinskiMiningProtocol();
  console.log("Token Allocation:", smp.allocateTokens());

  // Initialize and demonstrate Living Matrix
  const livingMatrix = new LivingMatrix();
  const livingMatrixLevel = 2;
  livingMatrix.initialize(livingMatrixLevel);
  const livingSegmentId = "root00"; // Adjusted to match segment IDs generated by fractalCoordinateSystem
  livingMatrix.updateTriangleState(livingSegmentId, { stateId: 1, description: "Living matrix updated state" });
  console.log(`Living matrix state for segment ${livingSegmentId}:`, livingMatrix.getTriangleState(livingSegmentId));

  // Additional implementation will proceed here

  // Demonstrate triangle subdivision and mining proof
  const level = 2;
  const triangles = smp.subdivideTriangle(level);
  console.log(`Triangle subdivision at level ${level}:`, triangles);

  const data = "sample data for PoFW";
  const targetDifficulty = 2; // Example difficulty level
  const proofResult = smp.performMiningProof(data, targetDifficulty);
  console.log("Mining proof result:", proofResult);

  // Demonstrate Proof of Fractal Work difficulty calculation
  const difficultyData = "sample data for PoFW";
  const difficultyTarget = 2; // Example difficulty level
  // Removed deprecated call to calculatePoFWDifficulty as it causes runtime error
  // const difficultyResult = smp.calculatePoFWDifficulty(difficultyData, difficultyTarget);
  // console.log(`PoFW difficulty check (target ${difficultyTarget}):`, difficultyResult);

  // Demonstrate dynamic scarcity calculation
  const scarcityLevel = 3;
  const scarcityValue = smp.calculateScarcity(scarcityLevel);
  console.log(`Scarcity value at level ${scarcityLevel}:`, scarcityValue);

  // Demonstrate Triple Burn Protocol
  const burnProtocol = new TripleBurnProtocol();
  burnProtocol.tripleBurn(9000);
  console.log("Total tokens burned:", burnProtocol.getTotalBurned());

  // Demonstrate Ancestral Dividend System
  const dividendSystem = new AncestralDividendSystem();
  const holders = [
    { share: 1000, ancestralLevel: 0 },
    { share: 500, ancestralLevel: 1 },
    { share: 250, ancestralLevel: 2 },
  ];
  const totalDividends = dividendSystem.distributeDividends(holders);
  console.log("Total dividends distributed:", totalDividends.toFixed(2));

  // Demonstrate Geometric Consensus Algorithm
  const consensus = new GeometricConsensus(0.75);
  const votes = [true, true, false, true, true];
  const consensusResult = consensus.validateConsensus(votes);
  console.log("Consensus validation result:", consensusResult);

  // Demonstrate Self-Organizing Economy Mechanisms
  const economy = new SelfOrganizingEconomy(100);
  const inputs = [110, 90, 105, 95, 100];
  for (const input of inputs) {
    const state = economy.feedbackStep(input);
    console.log(`Economic state after input ${input}:`, state.toFixed(2));
  }

  // Demonstrate Fractal Smart Contracts
  const contract = new FractalSmartContract({ balance: 1000 });
  contract.registerFunction('transfer', (state, amount) => {
    if (amount > state.balance) {
      throw new Error('Insufficient balance');
    }
    return { ...state, balance: state.balance - amount };
  });

  console.log("Initial contract state:", contract.getState());
  contract.executeFunction('transfer', 200);
  console.log("Contract state after transfer:", contract.getState());

  // Demonstrate Oracle Triangle System
  const oracleSystem = new OracleTriangleSystem();
  const source = "MockOracleFeed";
  const oracleData = await oracleSystem.fetchOracleData(source);
  console.log(`Oracle data from ${source}:`, oracleData);

  // Demonstrate Network Governance and Voting Protocols
  const governance = new NetworkGovernance();
  governance.createProposal("proposal1", "Increase token supply");
  governance.castVote("proposal1", "voter1", 10);
  governance.castVote("proposal1", "voter2", 20);
  governance.castVote("proposal1", "voter3", 15);
  console.log("Total votes cast:", governance.getTotalVotes("proposal1"));
  console.log("Vote weight for voter2:", governance.getVoteWeight("proposal1", "voter2"));
  console.log("Proposal passed:", governance.proposalPassed("proposal1", 0.6));

  // Demonstrate Sierpinski Virtual Machine (SVM)
  const svm = new SierpinskiVirtualMachine();
  svm.deployContract("contract1", { balance: 1000 });
  svm.registerContractFunction("contract1", "transfer", (state, amount) => {
    if (amount > state.balance) {
      throw new Error("Insufficient balance");
    }
    return { ...state, balance: state.balance - amount };
  });
  console.log("Initial contract state:", svm.getContractState("contract1"));
  svm.executeContractFunction("contract1", "transfer", 200);
  console.log("Contract state after transfer:", svm.getContractState("contract1"));
}

main().catch((error) => {
  console.error("Error during SMLP protocol execution:", error);
  process.exit(1);
});
